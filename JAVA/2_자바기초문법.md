# 자바 기초 문법 정리

> [ 이것이 자바다 - 신용권의 자바 프로그래밍 정복 ] 복습용 자료, 제어문은 생략. 



## 변수

### 기본적인 사용

- 자바에서의 변수는 한 가지 타입의 값만 저장할 수 있다.
- 변수를 사용하기 위해서 먼저 변수 선언을 해줘야 한다. **선언과 동시에 초기화도 가능하다.**
- 같은 타입의 변수는 콤마를 이용해서 한꺼번에 선언할 수 있다.
- 변수 이름은 명명 규칙을 따라야 한다.
  - 첫번째 글자는 문자, $, \_ 이어야 한다. 숫자는 첫번째로 올 수 없다.
  - 영어 대소문자가 구분된다.
  - 첫 문자는 소문자로 시작하고 다른 단어가 붙을 경우, 그 단어의 첫 문자를 대문자로 한다.
  - 길이 제한은 없으며 예약어 사용이 불가능하다.
- 소스코드 내에서 직접 변수에 저장하는 값들을 리터럴이라고 하며 정해진 표기법이 존재한다.
  - 정수 리터럴
    - **0으로 시작되는 정수 리터럴은 8진수로 간주한다.**
    - 0x으로 시작되는 정수 리터럴은 16진수로 간주한다.
  - 소수 리터럴
    - e, E 가 있는 소수 리터럴은 10진수 지수와 가수로 간주한다.
  - 문자 리터럴
    - 하나의 문자를 작은 따옴표로 묶는다.
  - 문자열 리터럴
    - 큰따옴표로 묶은 텍스트로, 큰따옴표 안에 텍스트가 없어도 문자열 리터럴로 간주된다.
  - 논리 리터럴
    - true, false
- 메소드 블록 내에서 선언된 변수를 로컬 변수라고 하며 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.
- 메소드 블록 뿐 만 아니라 제어문(for, while 등) 블록 내에서 선언된 변수 또한 해당 제어문 블록 안에서만 사용이 가능하다.

### 정수 타입

- **자바는 기본적으로 정수 연산을 Int 타입으로 수행한다.**
- byte 타입은 색상 정보, 파일 또는 이미지 등의 이진 데이터를 처리할 때 주로 사용된다.
- 범위를 넘어서는 값을 입력하면 원하던 값이 아닌 다른 값이 저장되며 이를 쓰레기값이라고 한다.
- 자바는 모든 문자를 유니코드로 처리한다. 유니코드는 하나의 문자에 대해 하나의 코드값을 부여하며, 0 ~ 65535 범위의 2byte를 가진 정수값이다. **자바는 하나의 유니코드를 저장하기 위해 2byte 크기의 char 타입을 제공한다.**
  - 음수를 포함하지 않는다.
  - char 타입 변수에 작은따옴표로 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다.
  - char 타입 변수에 문자가 아니라 유니코드 정수값을 저장할 수도 있다. 10진수와 16진수로 입력이 가능하며 10진수는 단순히 숫자를 입력하면 된다. **16진수는 '\u0041'과 같이 '\u + 16진수'**의 형태로 값을 저장하면 된다.
  - char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면 된다.
  - 초기화를 위해 최소한 공백 문자 하나를 포함해야한다.
- long 타입은 뒤에 소문자나 대문자 L 을 붙여주어야 한다. int 범위를 넘어가는 정수에 L 을 붙이지 않으면 컴파일 에러가 일어난다.

### 실수 타입

- 정수 타입과 다른 저장 방식 때문에 정수 타입보다 휠씬 더 큰 범위의 값을 저장할 수 있다.
- 실수는 부동 소수점 방식으로 저장되며 부호, 이는 가수, 지수 부분을 나누어 저장하는 방식이다.
- 가수 m은 0<= m <= 1범위의 실수여야한다.
- 가수를 표현하는데 있어서 double에 float 의 약 두배의 자릿수가 배정되어 있기 때문에 높은 정밀도를 요구하는 계산에서는 double을 사용해야 한다.
- **자바는 실수 리터럴의 기본 타입을 double로 간주한다.**
- float 타입 변수를 저장하려면 리터럴 뒤에 소문자나 대문자 f를 붙여야한다.
- 정수 리터럴에 10의 지수를 나타내는 e, E 를 포함하고 있으면 정수 타입 변수에 저장할 수 없고 실수 타입 변수에 저장해야한다.

### 논리 타입

- boolean 타입은 true, false로 이루어져있다.

### 타입변환

타입 변환에는 두 가지 종류가 있는데, 자동 타입 변환과 강제 타입 변환으로 나누어진다.

- 자동 타입 변환 : 프로그램 실행 중 자동으로 타입 변환. 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.

  - byte < short < int < long < float < double
  - char은 음수를 포함하지 않기 때문에 int 타입으로는 자동 변환되지만 음수를 포함하는 byte 타입으로는 자동 변환 불가능하다.

- 강제 타입 변환 : 큰 크기의 타입은 작은 크기 타입으로 자동 타입 변환을 할 수 없기 때문에 강제적으로 데이터를 쪼개어 저장하는 변환 방식이다.

  - 강제 타입 변환에서 주의할 점은 사용자로부터 입력받은 값을 변환할 때 값의 손실이 발생하면 안된다는 것이다. 따라서 타입 변환을 하기 전에 우선 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.

    ```java
    public class CheckValueBeforeCasting {
      public static void main(String[] args){
        int i = 128;

        if( (i<Byte.MIN_VALUE) || (i>Byte.MAX_VALUE)) {
          System.out.println("byte 타입으로 변환할 수 없다.");
        } else {
          byte b = (byte)i;
          System.out.println(b);
        }
      }
    }
    ```

  - 또 다른 주의점으로는 정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야한다는 점이 있다. int 타입을 안전하게 실수형으로 타입 변환하기 위해서는 double 타입을 사용해야한다.

### 연산식에서의 자동 타입 변환

연산은 기본적으로 같은 타입의 피연산자 간에만 수행되기 때문에 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다. 그 결과 또한 큰 타입으로 정해지며 만약 작은 타입의 결과를 얻고 싶다면 큰 타입의 피연산자를 작은 타입으로 변환한 후 연산을 수행한다.

- 정수 연산의 경우 자바는 int 타입을 기본으로 한다. 그 이유는 피연산자를 4byte 단위로 저장하기 때문이다. 따라서 **크기가 4byte 보다 작은 타입들의 연산 결과가 int 타입으로 산출된다.** 이 결과값을 바로 작은 타입들에 저장하려면 결과값을 작은 타입으로 형 변환 해주어야 한다.
- 실수 연산은 float + float 의 결과는 float으로 산출되지만, 피연산자 중에 실수 리터럴이나 double 타입이 있다면 다른 피연산자도 doulbe 타입으로 자동 타입 변환되어 연산된다.
- 정수 / 정수 계산하면 결과도 정수이고 그걸 실수 타입에 저장하면 정수형 결과에 .0이 붙게 됨. 실수로 연산하고 싶으면 적어도 하나는 실수여야된다. **주의할 것!!**





## 연산자

### 방향과 우선순위

- 방향

  - 대부분의 연산자는 왼쪽에서부터 오른쪽으로 연산을 시작한다.
  - 하지만 단항 연산자, 부호 연산자, 대입 연산자는 오른쪽에서 왼쪽으로 연산된다.
    - 단항 연산자 = [ ++, --, ~, ! ]
    - 부호 연산자 [ +, - ]
    - 대입 연산자 = [ =, +=, -=, ...]

- 우선순위

  - 증감, 부호, 비트, 논리 > 산술 > 쉬프트 > 비교 > 논리 > 조건 > 대입

    - y = x-- + 5 + --x; 의 경우 (x = 10)

      - x-- + 5 먼저 실행 --> 15 (감소 연산자가 피연산자의 뒤쪽에 위치하므로 덧셈 연산 먼저 수행)

      - 덧셈 연산 수행 후, 감소 연산이 수행되어 x 값이 9가 됨

      - --x 감소 연산 수행 --> x = 8

      - 15 + 8 수행 --> 23

  - 여러가지 연산이 섞여들어가면 혼란스러울 수 있으니 괄호를 사용하여 먼저 처리해야 할 연산식을 묶는 것이 좋다.

  - 괄호 부분의 연산은 최우선순위를 갖는다.

### 단항 연산자

1. 부호 연산자
   - \+ 연산자는 변수 값의 부호를 유지하며, - 연산자는 변수 값의 부호를 반전시킨다.
   - 부호 연산자의 산출 타입은 int 타입이다.
2. 증감 연산자( ++/ -- )
3. 논리 부정 연산자( ! )
4. 비트 반전 연산자( ~ )
   - 정수 타입의 피연산자에만 사용되며, 피연산자를 2진수로 표현했을 때 비트값을 반전 시킨다.
   - 비트 반전 연산자의 산출 타입은 int 타입이다.

### 주의점

1. 오버플로우

2. 실수의 정확한 연산이 필요할 때는 실수를 정수로 바꿔서 계산하고 다시 실수로 바꿔준다.

3. NaN 과 Infinity

   / 또는 % 를 사용할 때, 좌측 피연산자가 정수 타입이면 우측 피연산자에 0을 사용할 수 없다. 이런 경우 컴파일은 되지만 예외가 발생한다. 그러나 0.0 으로 나누면 / 연산 결과는 NaN, % 연산 결과는 Infinity 가 된다.

4. 실수 입력 받을 때는 NaN 검사를 해줘야한다. 용자가 입력한 NaN 문자열은 실수형으로 타입변환이 가능하고, 이 값을 이용해 연산을 진행하게 되면 데이터가 엉망이 되기 때문이다.

   - NaN은 != 연산자를 제외한 모든 비교 연산자를 사용할 경우 false 값을 리턴한다. 따라서 변수타입 == NaN 과 같은 조건식을 사용해서는 안된다.
   - 따라서 Double.isNaN( ) 메소드를 사용해서 검사해야한다.

5. 문자열과 숫자가 혼합된 + 연산은 왼쪽에서부터 오른쪽으로 진행된다.

6. 실수 타입은 0.1을 정확히 표현할 수 없기 때문에 비교연산 시 예외가 발생하는데 0.1 != 0.1f 이다.
   만약 두개를 같게 하기 위해서는 피연산자를 모두 float 타입으로 강제 변환한 후 비교 연산을 하거나 정수로 변환해서 비교하면 된다.

7. String은 비교연산자를 사용할 수는 있으나 문자열이 같은지 다른지 비교하는 용도로는 사용되지 않는다.
   자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어있는데, 객체 생성 연산자인 new 로 같은 문자열을 생성하면 다른 번지값을 가지게 된다. 같은 문자열이더라도 다른 객체가 되어 == 연산의 결과가 false가 될 수 있다.
   **문자열이 같은지를 비교하기 위해서는 원본문자열.equals( 비교문자열 ) 메소드를 사용한다.**





## 참조 타입

자바의 데이터 타입은 크게 기본 타입(원시타입)과 참조 타입으로 분류된다.

* 기본 타입 :  정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다.
* 참조 타입 : 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말한다.

기본 타입과 참조 타입으로 선언된 변수의 차이점은 저장되는 값이 무엇이냐이다. 기본 타입인 Int, char 등을 이용해서 선언된 변수는 실제 값을 변수 안에 저장하지만, 참조 타입인 배열, 열거, 클래스등을 이용해서 선언된 변수는 **메모리의 번지**를 값으로 갖는다. 번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다. 

* 자바에서 변수는 메모리 영역중 스택 영역에 생성되고 객체는 힙 영역에 생성된다. 스택 영역에 생성된 기본 타입 변수들은 직접 값을 가지고 있지만, 참조 타입 변수들은 힙 영역에 생성된 객체의 주소 값을 가지고 있다. 

* 기본 타입의 ==, !=  연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다. 

* 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. null 값을 가진 참조 타입 변수를 사용하면 NullPointException이 발생한다. 

### String 타입

* 일반적으로 String 변수에 저장한다는 표현이 사용되지만, 문자열은 String 객체로 생성되고, String 타입 변수는 그 객체를 참조한다.
* 자바는 문자열 리터럴이 동일하다면 같은 객체를 공유하도록 되어있다. 
* 일반적으로 변수에 문자열을 저장할 경우에는 문자열 리터럴을 사용하지만, new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다. 이 경우 같은 문자열을 가지더라도 다른 객체로 인식된다.
  * new 연산자는 객체 생성 연산자로 새로운 객체를 만들 때 사용하는 연산자이다.

### 배열 타입

배열은 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스를 부여해 놓은 자료구조이다. 

* 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다. 만약 길이를 바꾸고 싶다면 원하는 길이를 가진 새로운 배열을 생성하고, 기존 배열 항목을 새 배열로 복사해야 한다.

* ~~~Java
  int a[]
  int[] a
  ~~~

  대괄호 [ ]는 배열 변수를 선언하는 기호로 사용되며, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다.

* ~~~java
  int a[] = {1, 2, 3}
  
  int b[]
  b = new int[]{1, 2, 3}
  
  int c[] = new int[5]
  c[1] = 1
  ~~~

  배열을 생성할 때, 미리 저장될 값의 목록이 있다면 변수 선언과 동시에 간단히 배열 객체를 만들 수 있다. 하지만 배열 변수를 미리 선언하고 이 후에 배열을 생성, 참조 하기 위해서는 new 연산자를 사용해야한다.

  메소드의 매개값이 배열일 때도 마찬가지로 new 연산자를 사용해야한다.

  값의 목록을 가지고 있지는 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자를 이용해서 배열의 길이까지 지정해주면 된다. 배열 생성 후, 새로운 값을 저장할 때는 대입 연산자를 사용한다.

* new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값을 갖게된다. 

(이것이 자바다 157P까지의 필기)