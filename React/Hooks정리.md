# React Hooks

## 등장 배경과 함수형 컴포넌트의 사용 이유

React Hooks, 리액트 훅은 리액트의 클래스형 컴포넌트가 함수형 컴포넌트의 기능을 사용할 수 있도록 해주는 기능이다. 리액트 16.8 버전 (2019년) 부터 추가된 공식 라이브러리로, 이 전 까지 클래스형 컴포넌트에서만 가능했던 state, life cycle 관리가 함수형 컴포넌트에서도 할 수 있게 되었다. 

클래스형 컴포넌트들은 리렌더링 되더라도 render() 를 제외한 나머지 메소드나 상태가 그대로 보존된다. 반면에 함수형 컴포넌트들은 리렌더링 될 때, 함수 안에 작성된 모든 코드가 다시 실행된다. 따라서 기본적으로 함수형 컴포넌트들은 기존에 가지고 있던 모든 코드와 변수를 기억할 수 없으며 당연히 상태 또한 기억할 수 없다. (상태란 **컴포넌트 안에서 관리 되고 시간이 지나면서 바뀌는 동적인 데이터**를 말한다.) 즉, 함수형 컴포넌트는 리렌더링 될 때 무조건 새로 선언이 되고, 초기화 되어 메모리에 할당된다. 리액트 훅은 브라우저에 메모리를 할당하여 함수형 컴포넌트가 상태를 기억할 수 있도록 한다. 

현재 공식문서에서는 **클래스형 컴포넌트보다 함수형 컴포넌트를 사용해서 새로운 리액트 프로젝트를 만들 것을 권장**한다. 그렇다면 공식문서가 클래스형 컴포넌트를 더이상 권장하지 않고 함수형 컴포넌트를 사용하라고 하는 이유는 무엇일까?

1. 클래스형 컴포넌트간 상태 관리 로직을 공유하기 위한 방법으로는 hoc, render props가 있다. 하지만 두 패턴 모두 처음보면 다소 이해하기 어려우며, 컴포넌트의 재구성을 강요하고 디버깅 시 코드 추적에 어려움이 있다. 반면에 리액트 훅은 사용자가 커스텀 훅을 만들어서 클래스형 컴포넌트를 사용할 때 보다 간단한 방법으로 상태관리 로직을 공유할 수 있다.

2. 클래스형 컴포넌트의 라이프사이클 메소드를 사용할 때 메소드들이 기능별로 세분화 되어있어 코드가 중복되는 경우가 있었다. 리액트 훅은 useEffect를 여러개 선언할 수 있으며 두번째 인자인 의존성 배열에 원하는 상태를 넣어서 연관된 동작을 하는 기능 단위로 묶어서 관리가 가능하다.

3. this는 자신이 속한 객체 또는 인스턴스를 가리키는 자기 참조 변수인데, 클래스형 컴포넌트에서는 this를 사용해야 클래스에 관련된 함수나 props, state등에 접근할 수 있기 때문에 불필요하게 코드가 길어지는 단점이 존재한다. 또한 클래스형 컴포넌트에서 this가 mutable한 값이기 때문에 렌더링중에 this가 변경되는 버그가 있는데 이것을 방지하기 위해서 추가적으로 작성해야할 코드들이 있다. 반면에 함수형 컴포넌트는 렌더링 시점의 값을 inmutable하게 유지한다.

   관련 예시와 더 세부적인 내용은 [이곳](https://overreacted.io/ko/how-are-function-components-different-from-classes/)에 잘 정리되어있다.



## 자주 사용하는 React Hooks 종류

### 기본 규칙

1. 컴포넌트 최상위에서만 호출해야한다. 반복문이나 조건문등에서 훅을 호출하면 안된다. 
   리액트 훅은 호출되는 순서에 의존하기 때문에 조건문이나 반복문 안에서 실행하게될 경우 해당 부분을 건너뛰는 일이 발생할 수 있기 때문이다. 
2. 리액트 함수 내에서만 호출해야한다.

### 자주 사용하는 React Hooks

1. useState : 함수형 컴포넌트가 가변적인 상태를 지닐 수 있도록 한다. 
2. useEffect : 리액트 컴포넌트가 마운트, 업데이트, 언마운트될 때 특정 작업을 수행할 수 있도록 한다.
3. useContext : 전역 데이터를 공유하기 위해 사용하는 context API을 좀 더 편리하게 사용할 수 있도록 한다. 
4. useRef : DOM을 선택하거나 컴포넌트 안에서 조회, 수정되지만 렌더링에 영향을 주지 않는 변수를 관리할 수 있도록 한다.
5. useReducer : 현재 상태와 업데이트를 위해 필요한 정보를 담은 액션 값을 전달받아서 새로운 상태를 반환한다. 
6. useMemo : 함수 컴포넌트 내부에서 발생하는 연산을 최적화 한다. 렌더링 하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식.
7. useCallback : useMemo와 비슷, 만들어 놨던 함수를 재사용할 수 있게 한다. 함수형 컴포넌트는 렌더링이 될 때 마다 함수가 재생성되는데 의존값이 변할 때나 마운트 되었을 때만 함수를 생성하도록 한다. 



참고

* https://blog.rhostem.com/posts/2019-08-18-reason-whey-react-hooks-opt-in
* https://www.dong-ki.com/it/437/
* https://velog.io/@dianaleee_/%EC%99%9C-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8Functional-Component%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80

* https://overreacted.io/ko/how-are-function-components-different-from-classes/